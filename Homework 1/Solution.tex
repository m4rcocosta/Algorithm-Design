\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{lineno}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage {tikz}
\usetikzlibrary {positioning}
\usepackage {xcolor}
\usepackage{titlesec}
\usepackage{varwidth}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\title{\textbf{Algorithm Design - Homework 1} \\ \bigskip \large \textbf{Sapienza University of Rome}}
\date{\textbf{\today}}
\author{\textbf{Marco Costa, 1691388}}
\pagestyle{fancy}
\fancyhead[L]{Marco Costa, 1691388}
\fancyhead[R]{Algorithm Design - Homework 1}

%section, subsection: space - left, before, after
\titlespacing{\section}{0em}{0em}{0em}
\titlespacing{\subsection}{0em}{0.5em}{0em}
\titlespacing{\subsubsection}{0em}{0.5em}{0em}
\setlength\parindent{0pt}

\begin{document}
\maketitle
\newpage

\section*{Exercise 1}
\subsection*{Problem}
Given as input the number of boxes $k$, the number of different rewards $n$ as well as
the cost $c_i$ (which is guaranteed to be integer) of every box, design an algorithm to find the expected optimal reward.
\subsubsection*{Solution}
In order to solve the problem, we can define a matrix \textit{M} composed of $k$ rows and $n$ columns, where the element $M[i, j]$ represents the expected value by opening the box i and having already as maximum prize j. \\
To populate the matrix we can use \textbf{backward induction}, proceeding first considering the last box and choosing what to do for all the possible prizes. Using this information, we can then determine what to do at the penultimate box. This process continues backwards until we have determined the best action for every possible prize for each box. So the element $\mathbf{M[0, 0]}$ is the expected optimal reward.\\
To improve the complexity to \textbf{\textit{O}}($n \cdot k$) we can eliminate the summations, since in the worst case we have a sum over $n$ (\textbf{\textit{O}}($n$)) in nested cycles (\textbf{\textit{O}}($n \cdot k$)) having a total cost of\textbf{\textit{O}}($n^2 \cdot k$). To do this we must distinguish the two cases:
\begin{itemize}
	\item \textbf{\textit{Last box}}: we can remove this summation using a mathematical trick: \\
	$\sum\limits_{i = j + 1}^n{i} = \sum\limits_{i = 0}^n{i} - \sum\limits_{i = 0}^j{i} = \frac{n \cdot (n+1)}{2} - \frac{j \cdot (j+1)}{2} = \frac{n \cdot (n+1) - j \cdot (j+1)}{2}$;
	\item \textbf{\textit{Other boxes}}: we can use an auxiliary vector in which we keep track of the sum of the elements of the matrix related to the box next to the current one.
\end{itemize}

Here there are the two \textbf{\textit{Algorithms}}:

\begin{minipage}[t]{0.49\textwidth}
\begin{algorithm}[H]
	\caption{Get optimal expected value (\textbf{\textit{O}}($n^2 \cdot k$))}\label{euclid}
	\begin{algorithmic}[1]
		\State $M[k, n+1] \gets 0$
		\For{$i$ in $(k-1, ..., 0)$}
		\For{$j$ in $(n+1, ..., 0)$}
		\State $r \gets 0$
		\If{$i = k-1$}
		\State $r \gets j \cdot \frac{j+1}{n+1} + \frac{1}{n+1}\sum\limits_{h = j + 1}^n{h} - c[i]$
		\Else
		\State \begin{varwidth}[t]{\linewidth} $r \gets M[i+1, j] \cdot \frac{j+1}{n+1} + \frac{1}{n+1} \cdot$ \par
			\hskip\algorithmicindent $\sum\limits_{h = j + 1}^n{M[i+1, h]} - c[i]$
		\end{varwidth}
		\EndIf
		\State $M[i, j] \gets \max(j, r)$
		\EndFor		
		\EndFor
		\State \Return $M[0, 0]$
	\end{algorithmic}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{0.49\textwidth}
\begin{algorithm}[H]
	\caption{Get optimal expected value (\textbf{\textit{O}}($n \cdot k$))}\label{euclid}
	\begin{algorithmic}[1]
		\State $M[k, n+1] \gets 0$
		\State $sums[n+1] \gets 0$
		\For{$i$ in $(k-1, ..., 0)$}
		\For{$j$ in $(n+1, ..., 0)$}
		\State $r \gets 0$
		\If{$i = k-1$}
			\State $r \gets j \cdot \frac{j+1}{n+1} + \frac{1}{n+1} \cdot \frac{n \cdot (n+1)-j \cdot (j+1)}{2} - c[i]$
		\Else
			\State $r \gets M[i+1, j] \cdot \frac{j+1}{n+1} + \frac{sums[j]}{n+1} - c[i]$
		\EndIf
		\State $M[i, j] \gets \max(j, r)$
		\If{$j = n$}
			\State $sums[j] \gets 0$
		\Else
			\State $sums[j] \gets sums[j+1] + M[i, j+1]$
		\EndIf
		\EndFor		
		\EndFor
		\State \Return $M[0, 0]$
	\end{algorithmic}
\end{algorithm}
\end{minipage}
\newpage

\section*{Exercise 2}
\subsection*{First problem}
Find the complete graph \textbf{\textit{G}} of minimum weight given a weighted tree \textbf{\textit{T}}, such that  \textbf{\textit{T}} is the unique minimum spanning tree of \textbf{\textit{G}}.
\subsubsection*{Solution}
Insert edges that are not in the tree so as to obtain the complete graph. These edges must have a greater weight than those of the tree, so that \textbf{\textit{T}} is the only \textbf{\textit{MST}} of \textbf{\textit{G}}. Since \textit{Kruskal}'s algorithm uses the \textit{Union-Find} structures for representing the cuts, we use this structures to solve the problem. \\
Let's define with \textbf{\textit{V}} the set of nodes of \textbf{\textit{T}} and with \textbf{\textit{E}} the set of edges of \textbf{\textit{T}}.
\begin{algorithm}
	\caption{Find complete graph}\label{euclid}
	\begin{algorithmic}[1]
		\For{$v \in V$}
			\State $v.initializeUnionFindSingleton()$
		\EndFor
		\State $T.sortEdgesByAscendingWeights()$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n\log{n}$))
		\State $G \gets \emptyset$
		\For {$e \gets (v_1, v_2) \in E$} \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n^2$))
			\State  $G.addEdge(e)$
			\State  $set_1 \gets v_1.findComponents()$
			\State  $set_2 \gets v_2.findComponents()$
			\For {$u \in set_1$}
				\For {$v \in set_2$}
					\State $\hat{e} \gets (u, v)$
					\If {$\hat{e} \notin E$}
						\State $\hat{e}.setWeight(e.getWeight() + 1)$
						\State $G.addEdge(\hat{e})$
					\EndIf
				\EndFor
			\EndFor
			\State $union(set_1, set_2)$
		\EndFor
		\State \Return $G$
	\end{algorithmic}
\end{algorithm} \\
\textbf{Cost}: Let's define \textbf{\textit{E'}} = set of edges of the graph \textbf{\textit{G}}, the cost is \textbf{\textit{O}}($|E'| + |V|\log{|V|}$), but $|E'| = \frac{|V| \cdot (|V| - 1)}{2}$ and $|V| = n$, so $|E'| + |V|\log{|V|} = \frac{n^2 - n}{2} + n\log{n}$ and the cost is \textbf{\textit{O}}($n^2$)
\subsection*{Second problem}
Find the total weight of the complete graph \textbf{\textit{G}} of minimum weight given a weighted tree \textbf{\textit{T}}, such that  \textbf{\textit{T}} is the unique minimum spanning tree of \textbf{\textit{G}}.
\subsubsection*{Solution}
This problem is quite similar to the previous one, but in this case there is no need to create all the edges of the graph.
\begin{algorithm}
	\caption{Find weight of the complete graph}\label{euclid}
	\begin{algorithmic}[1]
		\For{$v \in V$}
			\State $v.initializeUnionFindSingleton()$
		\EndFor
		\State $T.sortEdgesByAscendingWeights()$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n\log{n}$))
		\State $w_{total} \gets 0$
		\For {$e \gets (v_1, v_2) \in E$} \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n$))
			\State $w_{total}$ \textit{+=} $e.getWeight()$
			\State  $set_1 \gets v_1.findComponents()$
			\State  $set_2 \gets v_2.findComponents()$
			\State $w_{total}$ \textit{+=} $(set_1.size() \times set_2.size() - 1) \times (e.getWeight() + 1)$
			\State $union(set_1, set_2)$
		\EndFor
		\State \Return $w_{total}$
	\end{algorithmic}
\end{algorithm} \\
\textbf{Cost}: \textbf{\textit{O}}($|V|\log{|V|} + |E|$) = \textbf{\textit{O}}($n\log{n} + (n-1)$) = \textbf{\textit{O}}($n\log{n}$), given by ordering the edges.
\newpage

\section*{Exercise 3}
\subsection*{First Problem}
Model the problem as a flow problem in a graph G, only consisting of regular vertices, one
source, one sink, and capacitated edges to find out how many chocolates Federico should
actually make every week. Give a formal definition of your network, and also draw a small
example, e.g. for $|F|$ = 4.
\subsubsection*{Solution}

\textbf{Example}:

\begin {tikzpicture}
\begin{scope}[auto=left,every node/.style={circle,draw, minimum width = 1 cm}]
\node(f) at (0,0) {F};
\node(ma) at (3,1) {m$_a$};
\node(a) at (6.5,1) {f$_a$};
\node(mb) at (3,-1) {m$_b$};
\node(b) at (6.5,-1) {f$_b$};
\node(mc) at (9.5,1) {m$_c$};
\node(c) at (13,1) {f$_c$};
\node(md) at (9.5,-1) {m$_d$};
\node(d) at (13,-1) {f$_d$};
\node(s) at (16,0) {s};
\end{scope}
\begin{scope}[every edge/.style={draw=black,very thick}]
\path [->] (f) edge node[sloped,above]{$n_1$} (ma);
\path [->] (f) edge node[sloped,above]{$n_2$} (mb);

\path [->] (a) edge node[sloped,below]{$n_a - s_a$} (mc);
\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (md);
\path [->] (c) edge[bend right=20] node[sloped,above]{$n_c - s_c$} (ma);
\path [->] (d) edge[bend left=20] node[sloped,below]{$n_d - s_d$} (mb);

\path [->] (a) edge[sloped,above,pos=0.75] node{$n_a - s_a$} (mb);
\path [->] (d) edge[sloped,above,pos=0.2] node{$n_d - s_d$} (mc);
\path [->] (b) edge[sloped,above,pos=0.2] node{$n_b - s_b$} (ma);
\path [->] (c) edge[sloped,above,pos=0.75] node{$n_c - s_c$} (md);

\path [->] (ma) edge node[sloped,above]{$n_a$}(a);
\path [->] (mb) edge node[sloped,above]{$n_b$}(b);
\path [->] (mc) edge node[sloped,above]{$n_c$}(c);
\path [->] (md) edge node[sloped,above]{$n_d$}(d);

\path [->] (a) edge[bend left=30] node[sloped,above]{$s_a$} (s);
\path [->] (b) edge[bend right=30] node[sloped,below]{$s_b$} (s);
\path [->] (c) edge node[sloped,above]{$s_c$} (s);
\path [->] (d) edge node[sloped,above]{$s_d$} (s);
\end{scope}
\end{tikzpicture}
\subsection*{Second Problem}
\subsubsection*{Solution}
\begin {tikzpicture}
\begin{scope}[auto=left,every node/.style={circle,draw, minimum width = 1 cm}]
	\node(f) at (0,0) {F};
	\node(ma) at (2,1) {m$_a$};
	\node(a) at (5.8,1) {f$_a$};
	\node(mb) at (2,-1) {m$_b$};
	\node(b) at (5.8,-1) {f$_b$};
	\node(mc) at (8.2,1) {m$_c$};
	\node(c) at (12,1) {f$_c$};
	\node(md) at (8.2,-1) {m$_d$};
	\node(d) at (12,-1) {f$_d$};
	\node(b1) at (14,2) {$b_1$};
	\node(b2) at (14,0) {$b_2$};
	\node(b3) at (14,-2) {$b_3$};
	\node(s) at (16,0) {s};
\end{scope}
\begin{scope}[every edge/.style={draw=black,very thick}]
	\path [->] (f) edge node[sloped,above]{$n_1$} (ma);
	\path [->] (f) edge node[sloped,above]{$n_2$} (mb);
	
	\path [->] (a) edge node[sloped,below]{$n_a - s_a$} (mc);
	\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (md);
	\path [->] (c) edge[bend right=20] node[sloped,above]{$n_c - s_c$} (ma);
	\path [->] (d) edge[bend left=20] node[sloped,below]{$n_d - s_d$} (mb);
	
	\path [->] (a) edge[sloped,above,pos=0.75] node{$n_a - s_a$} (mb);
	\path [->] (d) edge[sloped,above,pos=0.2] node{$n_d - s_d$} (mc);
	\path [->] (b) edge[sloped,above,pos=0.2] node{$n_b - s_b$} (ma);
	\path [->] (c) edge[sloped,above,pos=0.75] node{$n_c - s_c$} (md);
	
	\path [->] (ma) edge node[sloped,above]{$n_a$}(a);
	\path [->] (mb) edge node[sloped,above]{$n_b$}(b);
	\path [->] (mc) edge node[sloped,above]{$n_c$}(c);
	\path [->] (md) edge node[sloped,above]{$n_d$}(d);
	
	\path [->] (a) edge[bend left=10] node[sloped,above]{$s_a$} (b1);
	\path [->] (b) edge[bend right=10] node[sloped,below]{$s_b$} (b3);
	\path [->] (c) edge node[sloped,above]{$s_c$} (b1);
	\path [->] (d) edge node[sloped,above]{$s_d$} (b2);
	
	\path [->] (b1) edge node[sloped,above]{$c_1$} (s);
	\path [->] (b2) edge node[sloped,above]{$c_2$} (s);
	\path [->] (b3) edge node[sloped,above]{$c_3$} (s);
\end{scope}
\end{tikzpicture}
\newpage

\section*{Exercise 4}
\subsection*{Problem}

\subsubsection*{Solution}
In order to prove that this problem is \textbf{NP-HARD}, we need to find a well-know \textbf{NP-HARD} algorithm s.t. $\alpha \le_p EX4$. We can do it with the \textbf{SUBSET SUM} problem. We can use a reduction from the problem above: given a set of integers $S = {x_1, x_2, ..., x_n}$ and a target integer $\gamma$, there exists a subset $S' \in S$ s.t. $\sum\limits_{x_i \in S'}x_i = K$
So, we construct an instance of the EX4 problem with n jobs, each having earliest start time $0$ (so $s_j = 0$ for all $j \in S'$). For $j \in J$, job $j$ has length $l_j = x_j$ and deadline $d_j = \gamma$. This instance solves the scheduling problem because we can arrange the jobs in any order and they will always meet their deadline. Now we need to prove
\end{document}
