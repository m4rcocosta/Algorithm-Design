\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{lineno}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage {tikz}
\usetikzlibrary {positioning}
\usepackage {xcolor}
\usepackage{titlesec}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\title{\textbf{Algorithm Design - Homework 1} \\ \bigskip \large \textbf{Sapienza University of Rome}}
\date{\textbf{\today}}
\author{\textbf{Marco Costa, 1691388}}
\pagestyle{fancy}
\fancyhead[L]{Marco Costa, 1691388}
\fancyhead[R]{Algorithm Design - Homework 1}

%section, subsection: space - left, before, after
\titlespacing{\section}{0em}{0em}{0em}
\titlespacing{\subsection}{0em}{0.5em}{0em}
\titlespacing{\subsubsection}{0em}{0.5em}{0em}
\setlength\parindent{0pt}

\begin{document}
\maketitle
\newpage

\section*{Exercise 1}
\subsection*{Problem}
Given as input the number of boxes $k$, the number of different rewards $n$ as well as
the cost $c_i$ (which is guaranteed to be integer) of every box, design an algorithm to find the expected optimal reward.
\subsubsection*{Solution}
\begin{algorithm}
	\caption{Get optimal expected value}\label{euclid}
	\begin{algorithmic}[1]
		\State $M[k, n+1] \gets 0$
		\State $c[k] \gets 0$
		\State $a[n+1] \gets 0$
		\For{$i$ in $(k-1, ..., 0)$}
		\For{$j$ in $(n+1, ..., 0)$}
		\State $nv \gets 0$
		\If{$i = k-1$}
			\State $nv \gets j \times \frac{j+1}{n+1} + \frac{1}{n+1} \times \frac{n \times (n+1)-j \times (j+1)}{2}) - c[i]$
		\Else
			\State $nv \gets M[i+1, j] \times \frac{j+1}{n+1} + \frac{1}{n+1} \times a[j] - c[i]$
		\EndIf
		\State $M[i, j] \gets \max(j, nv)$
		\If{$j = n$}
			\State $a[j] \gets 0$
		\Else
			\State $a[j] \gets a[j+1] + matrix[i, j+1]$
		\EndIf
		\EndFor		
		\EndFor
		\State \Return $M[0, 0]$
	\end{algorithmic}
\end{algorithm}
\newpage

\section*{Exercise 2}
\subsection*{First problem}
Find the complete graph \textbf{\textit{G}} of minimum weight given a weighted tree \textbf{\textit{T}}, such that  \textbf{\textit{T}} is the unique minimum spanning tree of \textbf{\textit{G}}.
\subsubsection*{Solution}
Insert edges that are not in the tree so as to obtain the complete graph. These edges must have a greater weight than those of the tree, so that \textbf{\textit{T}} is the only \textbf{\textit{MST}} of \textbf{\textit{G}}. Since \textit{Kruskal}'s algorithm uses the \textit{Union-Find} structures for representing the cuts, we use this structures to solve the problem. \\
Let's define with \textbf{\textit{V}} the set of nodes of \textbf{\textit{T}} and with \textbf{\textit{E}} the set of edges of \textbf{\textit{T}}.
\begin{algorithm}
	\caption{Find complete graph}\label{euclid}
	\begin{algorithmic}[1]
		\For{$v \in V$}
			\State $v.initializeUnionFindSingleton()$
		\EndFor
		\State $T.sortEdgesByAscendingWeights()$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n\log{n}$))
		\State $G \gets \emptyset$
		\For {$e \gets (v_1, v_2) \in E$} \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n^2$))
			\State  $G.addEdge(e)$
			\State  $set_1 \gets v_1.findComponents()$
			\State  $set_2 \gets v_2.findComponents()$
			\For {$u \in set_1$}
				\For {$v \in set_2$}
					\State $\hat{e} \gets (u, v)$
					\If {$\hat{e} \notin E$}
						\State $\hat{e}.setWeight(e.getWeight() + 1)$
						\State $G.addEdge(\hat{e})$
					\EndIf
				\EndFor
			\EndFor
			\State $union(set_1, set_2)$
		\EndFor
		\State \Return $G$
	\end{algorithmic}
\end{algorithm} \\
\textbf{Cost}: Let's define \textbf{\textit{E'}} = set of edges of the graph \textbf{\textit{G}}, the cost is \textbf{\textit{O}}($|E'| + |V|\log{|V|}$), but $|E'| = \frac{|V|(|V| - 1)}{2}$ and $|V| = n$, so $|E'| + |V|\log{|V|} = \frac{n^2 - n}{2} + n\log{n}$ and the cost is \textbf{\textit{O}}($n^2$)
\subsection*{Second problem}
Find the total weight of the complete graph \textbf{\textit{G}} of minimum weight given a weighted tree \textbf{\textit{T}}, such that  \textbf{\textit{T}} is the unique minimum spanning tree of \textbf{\textit{G}}.
\subsubsection*{Solution}
This problem is quite similar to the previous one, but in this case there is no need to create all the edges of the graph.
\begin{algorithm}
	\caption{Find weight of the complete graph}\label{euclid}
	\begin{algorithmic}[1]
		\For{$v \in V$}
			\State $v.initializeUnionFindSingleton()$
		\EndFor
		\State $T.sortEdgesByAscendingWeights()$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n\log{n}$))
		\State $w_{total} \gets 0$
		\For {$e \gets (v_1, v_2) \in E$} \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad (\textbf{\textit{O}}($n$))
			\State $w_{total}$ \textit{+=} $e.getWeight()$
			\State  $set_1 \gets v_1.findComponents()$
			\State  $set_2 \gets v_2.findComponents()$
			\State $w_{total}$ \textit{+=} $(set_1.size() \times set_2.size() - 1) \times (e.getWeight() + 1)$
			\State $union(set_1, set_2)$
		\EndFor
		\State \Return $w_{total}$
	\end{algorithmic}
\end{algorithm} \\
\textbf{Cost}: \textbf{\textit{O}}($|V|\log{|V|} + |E|$) = \textbf{\textit{O}}($n\log{n} + (n-1)$) = \textbf{\textit{O}}($n\log{n}$), given by ordering the edges.
\newpage

\section*{Exercise 3}
\subsection*{First Problem}
Model the problem as a flow problem in a graph G, only consisting of regular vertices, one
source, one sink, and capacitated edges to find out how many chocolates Federico should
actually make every week. Give a formal definition of your network, and also draw a small
example, e.g. for $|F|$ = 4.
\subsubsection*{Solution}

\textbf{Example}:

\begin {tikzpicture}
\begin{scope}[auto=left,every node/.style={circle,draw, minimum width = 1 cm}]
\node(f) at (0,0) {F};
\node(a) at (5.5,1) {f$_a$};
\node(b) at (5.5,-1) {f$_b$};
\node(c) at (11,1) {f$_c$};
\node(d) at (11,-1) {f$_d$};
\node(s) at (16,0) {s};
\end{scope}
\begin{scope}[every edge/.style={draw=black,very thick}]
\path [->] (f) edge node[sloped,above]{$n_a$} (a);
\path [->] (f) edge node[sloped,above]{$n_b$} (b);

\path [->] (a) edge node[sloped,above]{$n_a - s_a$} (c);
\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (c);
\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (d);

\path [->] (a) edge[left] node{$n_a - s_a$} (b);
\path [->] (d) edge[right] node{$n_d - s_d$} (c);

\path [->] (a) edge[bend left=25] node[sloped,above]{$s_a$} (s);
\path [->] (c) edge node[sloped,above]{$s_c$} (s);
\path [->] (d) edge node[sloped,above]{$s_d$} (s);
\end{scope}
\end{tikzpicture}
\subsection*{Second Problem}
\subsubsection*{Solution}
\begin {tikzpicture}
\begin{scope}[auto=left,every node/.style={circle,draw, minimum width = 1 cm}]
	\node(f) at (0,0) {F};
	\node(a) at (4,1) {f$_a$};
	\node(b) at (4,-1) {f$_b$};
	\node(c) at (8,1) {f$_c$};
	\node(d) at (8,-1) {f$_d$};
	\node(b1) at (12,2) {$b_1$};
	\node(b2) at (12,0) {$b_2$};
	\node(b3) at (12,-2) {$b_3$};
	\node(s) at (16,0) {s};
\end{scope}
\begin{scope}[every edge/.style={draw=black,very thick}]
	\path [->] (f) edge node[sloped,above]{$n_a$} (a);
	\path [->] (f) edge node[sloped,above]{$n_b$} (b);
	
	\path [->] (a) edge node[pos=0.6,sloped,above]{$n_a - s_a$} (c);
	\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (c);
	\path [->] (b) edge node[sloped,above]{$n_b - s_b$} (d);
	
	\path [->] (a) edge[left] node{$n_a - s_a$} (b);
	\path [->] (d) edge[right] node{$n_d - s_d$} (c);
	
	\path [->] (a) edge[bend left=10] node[sloped,above]{$s_a$} (b1);
	\path [->] (c) edge node[sloped,above]{$s_c$} (b2);
	\path [->] (d) edge node[sloped,above]{$s_d$} (b3);
	
	\path [->] (b1) edge node[sloped,above]{$c_1$} (s);
	\path [->] (b2) edge node[sloped,above]{$c_2$} (s);
	\path [->] (b3) edge node[sloped,above]{$c_3$} (s);
\end{scope}
\end{tikzpicture}
\newpage

\section*{Exercise 4}
\subsection*{Problem}

\subsubsection*{Solution}
In order to prove that this problem is \textbf{NP-HARD}, we need to find a well-know \textbf{NP-HARD} algorithm s.t. $\alpha \le_p EX4$. We can do it with the \textbf{SUBSET SUM} problem. We can use a reduction from the problem above: given a set of integers $S = {x_1, x_2, ..., x_n}$ and a target integer $\gamma$, there exists a subset $S' \in S$ s.t. $\sum\limits_{x_i \in S'}x_i = K$
So, we construct an instance of the EX4 problem with n jobs, each having earliest start time $0$ (so $s_j = 0$ for all $j \in S'$). For $j \in J$, job $j$ has length $l_j = x_j$ and deadline $d_j = \gamma$. This instance solves the scheduling problem because we can arrange the jobs in any order and they will always meet their deadline. Now we need to prove
\end{document}
